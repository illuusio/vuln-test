{
    "affected": [
        {
            "package": {
                "ecosystem": "FreeBSD:ports",
                "name": "curl"
            },
            "ranges": [
                {
                    "events": [
                        {
                            "introduced": "7.20.0"
                        },
                        {
                            "fixed": "7.71.0"
                        }
                    ],
                    "type": "ECOSYSTEM"
                }
            ]
        }
    ],
    "database_specific": {
        "cite": [
            "https://curl.haxx.se/docs/security.html"
        ],
        "discovery": "2020-06-24T00:00:00Z",
        "references": {
            "cvename": [
                "CVE-2020-8169",
                "CVE-2020-8177"
            ]
        },
        "vid": "6bff5ca6-b61a-11ea-aef4-08002728f74c"
    },
    "details": "curl security problems:\n\n> CVE-2020-8169: Partial password leak over DNS on HTTP redirect\n>\n> libcurl can be tricked to prepend a part of the password to the host\n> name before it resolves it, potentially leaking the partial password\n> over the network and to the DNS server(s).\n>\n> libcurl can be given a username and password for HTTP authentication\n> when requesting an HTTP resource - used for HTTP Authentication such\n> as Basic, Digest, NTLM and similar. The credentials are set, either\n> together with CURLOPT_USERPWD or separately with CURLOPT_USERNAME and\n> CURLOPT_PASSWORD. Important detail: these strings are given to libcurl\n> as plain C strings and they are not supposed to be URL encoded.\n>\n> In addition, libcurl also allows the credentials to be set in the URL,\n> using the standard RFC 3986 format: http://user:password@host/path. In\n> this case, the name and password are URL encoded as that\\'s how they\n> appear in URLs.\n>\n> If the options are set, they override the credentials set in the URL.\n>\n> Internally, this is handled by storing the credentials in the \\\"URL\n> object\\\" so that there is only a single set of credentials stored\n> associated with this single URL.\n>\n> When libcurl handles a relative redirect (as opposed to an absolute\n> URL redirect) for an HTTP transfer, the server is only sending a new\n> path to the client and that path is applied on to the existing URL.\n> That \\\"applying\\\" of the relative path on top of an absolute URL is\n> done by libcurl first generating a full absolute URL out of all the\n> components it has, then it applies the redirect and finally it\n> deconstructs the URL again into its separate components.\n>\n> This security vulnerability originates in the fact that curl did not\n> correctly URL encode the credential data when set using one of the\n> curl_easy_setopt options described above. This made curl generate a\n> badly formatted full URL when it would do a redirect and the final\n> re-parsing of the URL would then go bad and wrongly consider a part of\n> the password field to belong to the host name.\n>\n> The wrong host name would then be used in a name resolve lookup,\n> potentially leaking the host name + partial password in clear text\n> over the network (if plain DNS was used) and in particular to the used\n> DNS server(s).\n>\n> CVE-2020-8177: curl overwrite local file with -J\n>\n> curl can be tricked by a malicious server to overwrite a local file\n> when using -J (\\--remote-header-name) and -i (\\--include) in the same\n> command line.\n>\n> The command line tool offers the -J option that saves a remote file\n> using the file name present in the Content-Disposition: response\n> header. curl then refuses to overwrite an existing local file using\n> the same name, if one already exists in the current directory.\n>\n> The -J flag is designed to save a response body, and so it doesn\\'t\n> work together with -i and there\\'s logic that forbids it. However, the\n> check is flawed and doesn\\'t properly check for when the options are\n> used in the reversed order: first using -J and then -i were mistakenly\n> accepted.\n>\n> The result of this mistake was that incoming HTTP headers could\n> overwrite a local file if one existed, as the check to avoid the local\n> file was done first when body data was received, and due to the\n> mistake mentioned above, it could already have received and saved\n> headers by that time.\n>\n> The saved file would only get response headers added to it, as it\n> would abort the saving when the first body byte arrives. A malicious\n> server could however still be made to send back virtually anything as\n> headers and curl would save them like this, until the first CRLF-CRLF\n> sequence appears.\n>\n> (Also note that -J needs to be used in combination with -O to have any\n> effect.)\n",
    "id": "FreeBSD-2020-0157",
    "modified": "2020-06-24T00:00:00Z",
    "published": "2020-06-24T00:00:00Z",
    "references": [
        {
            "type": "REPORT",
            "url": "https://curl.haxx.se/docs/security.html"
        },
        {
            "type": "WEB",
            "url": "https://curl.haxx.se/docs/security.html"
        },
        {
            "type": "WEB",
            "url": "https://curl.haxx.se/docs/CVE-2020-8169.html"
        },
        {
            "type": "WEB",
            "url": "https://curl.haxx.se/docs/CVE-2020-8177.html"
        },
        {
            "type": "ADVISORY",
            "url": "https://api.osv.dev/v1/vulns/CVE-2020-8169"
        },
        {
            "type": "ADVISORY",
            "url": "https://api.osv.dev/v1/vulns/CVE-2020-8177"
        }
    ],
    "schema_version": "1.7.0",
    "summary": "curl -- multiple vulnerabilities"
}
